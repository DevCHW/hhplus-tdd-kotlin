# 항해플러스 [1주차 과제] TDD로 개발하기

## 요구 사항
### API
- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.

### 예외 케이스
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.  
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 **순차적으로** 처리되어야 합니다.

---
## 구현 단계
### `요구사항 구현`
- `/point` 패키지 (디렉토리) 내에 `PointService` 기본 기능 작성   
- `/database` 패키지의 구현체는 수정하지 않고, 이를 활용해 기능을 구현   
- 각 기능에 대한 단위 테스트 작성

### `Step1. 기본 과제`
- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)   
- 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링   
- 동시성 제어에 대한 통합 테스트 작성


### `Step2. 심화 과제`
- 동시성 제어 분석 보고서 작성

---
## 동시성 제어 분석 보고서

### 동시성 제어란?
동시성 제어(Concurrency Control)는 여러 프로세스나 사용자들이 동시에 데이터베이스나 시스템의 자원에 접근하는 상황에서 데이터의 일관성과 정확성을 유지하기 위한 기법입니다. 주로 데이터베이스 시스템에서 많이 사용되며, 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제를 해결하는 데 초점을 둡니다.

### 선택한 동시성 제어 기법과 근거
`ConcurrentHashMap`과 `ReentrantLock`을 이용하였습니다.

- **ConcurrentHashMap**
  - `HashTable`, `SynchronizedMap`은 임계영역이 과도하게 설정되어 있어 멀티 스레드 환경에서 안전하기는 하지만 성능이 떨어집니다. 반면 `ConcurrentHashMap`은 데이터 변경 부분에만 임계 영역이 설정되어 있기 때문에 성능상 이점이 있어 선택하였습니다.

- **ReentrantLock**
  - Semaphore의 공유변수를 1로 설정하여 사용할 수도 있지만, 과제의 요구사항 중 **순차적으로**라는 기준을 저는 **Lock을 획득하기 위하여 기다린 순서대로** 라고 해석했기에, `ReentrantLock`의 공정모드를 활용하여 구현하였습니다.

위 기법을 통해 **동일한 유저의 포인트**에 대해서만 임계 영역을 설정하고, 변경이 일어나는 포인트 충전 / 사용 부분에만 동시성 제어 로직을 적용하여 최대한의 성능을 보장하고자 했습니다.

### 개선해야 할 부분
유저가 포인트 충전이나 사용을 할 경우, `ConcurrentHashMap` 내부에 생성된 `ReentrantLock` 인스턴스는 제거되지 않습니다. 따라서 포인트 사용/충전을 이용한 유저가 많아질 수록 제거되지 못하는 인스턴스가 계속 남아있기 때문에 메모리 누수가 발생합니다.


이러한 문제를 해결하기 위하여 주기적으로 포인트 충전, 사용 기능을 차단한 뒤 `ConcurrentHashMap` 내부를 청소해주는 방법을 떠올렸으나 이는 사용자 경험에 좋지 못할 것 같아 다른 방법을 모색해야 합니다.


### 참고 사항
- 높은 테스트 커버리지를 달성하고자 하지 않았습니다. 해당 과제의 주 목적은 소프트웨어가 제대로 동작하고 있는지 **정확하게 잘 검증**하는 능력을 기르기 위한 것이므로 이러한 부분에 초점을 두었습니다.
- 분산 환경은 고려하지 않았습니다.
- DB와 같은 외부 컴포넌트에 대해서 고려하지 않았습니다.


